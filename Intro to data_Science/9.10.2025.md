
Assignment later: matrix size calculations and make a graph and make the plot 
=> Study struct and nested structs.
=> Assignment 1: Matrix Multiplication start from 250 * 250 run it till your PC can handle. Log time required to process. Plot the time required by size. Record Only the time required to perform the matrix multiplication.


T
|
|
|
|
|
|_______ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ N * N

=> Assignment 2: Read data from file and to different operations.

Deadline for Assignment -> By 20 OCT 2025

### struct
Structures are sometimes referred to aggregates - collection of related variables under one name.

1. At the end of a struct there mustÂ beÂ aÂ semicolon.


Perfect â€” you took a useful photo! ğŸ“¸

From whatâ€™s visible on the whiteboard, your class is covering **structures (`struct`)**, **typedefs**, and **pointers to structures** in **C language**. Letâ€™s go through everything step-by-step so you can catch up easily and understand it deeply ğŸ‘‡

---

## ğŸ§© 1. What is a Structure (`struct`)?

A **structure** in C is a **user-defined data type** that lets you group **different data types** under one name.

Think of it like a **container** that can hold related information together â€” for example, details about a student (name, grade, gender, etc.).

### ğŸ“˜ Example:

```c
#include <stdio.h>

struct Student {
    char name[50];
    char schoolName[50];
    int grade;
    char letterGrade;
    char gender;
};
```

Here:

* `struct Student` is the **structure definition**.
* Inside the `{}` are **members** (variables) of different data types.

---

## ğŸ§® 2. Declaring Structure Variables

Once a structure is defined, you can create variables of that structure type:

```c
struct Student s1, s2;
```

Each variable (`s1`, `s2`) now has its own set of members:

* `s1.name`, `s1.grade`, `s1.gender`, etc.

You can also create **an array of structures**:

```c
struct Student students[50];
```

This can store 50 studentsâ€™ information.

---

## ğŸ§  3. Accessing Members

Use the **dot operator (`.`)** to access members.

```c
strcpy(s1.name, "Alice");
s1.grade = 90;
s1.gender = 'F';
```

To **print**:

```c
printf("Name: %s, Grade: %d, Gender: %c\n", s1.name, s1.grade, s1.gender);
```

---

## ğŸ§¾ 4. Using `typedef` with Structures

Typing `struct Student` repeatedly can be annoying.
So we use `typedef` to give it a simpler name:

```c
typedef struct Student {
    char name[50];
    int grade;
    char gender;
} STUDENT;
```

Now you can declare variables like:

```c
STUDENT s1, s2;
```

instead of writing `struct Student s1;`

---

## ğŸ’¡ 5. Pointers to Structures

You can also create a **pointer** to a structure:

```c
STUDENT s1 = {"Alice", 90, 'F'};
STUDENT *ptr = &s1;
```

Now you can access members in **two ways**:

1. Using dot operator â†’ `s1.grade`
2. Using pointer and arrow operator â†’ `ptr->grade`

Both give the same value.

### Example:

```c
printf("Student name: %s\n", ptr->name);
printf("Student grade: %d\n", ptr->grade);
```

---

## ğŸ§© 6. Example Program Combining All

Hereâ€™s a complete example similar to whatâ€™s on the whiteboard ğŸ‘‡

```c
#include <stdio.h>
#include <string.h>

typedef struct {
    char name[50];
    char schoolName[50];
    int grade;
    char letterGrade;
    char gender;
} STUDENT;

int main() {
    STUDENT s1, *ptr;

    strcpy(s1.name, "Alice");
    strcpy(s1.schoolName, "Tech High");
    s1.grade = 95;
    s1.letterGrade = 'A';
    s1.gender = 'F';

    ptr = &s1;

    printf("Using dot operator:\n");
    printf("Name: %s, Grade: %d, Gender: %c\n", s1.name, s1.grade, s1.gender);

    printf("\nUsing pointer and arrow operator:\n");
    printf("Name: %s, Grade: %d, Gender: %c\n", ptr->name, ptr->grade, ptr->gender);

    return 0;
}
```

---

## ğŸ§  Key Takeaways

| Concept            | Syntax                            | Description                 |
| ------------------ | --------------------------------- | --------------------------- |
| Define a struct    | `struct Student { ... };`         | Creates a custom data type  |
| Create variable    | `struct Student s1;`              | Creates one instance        |
| Access members     | `s1.name`                         | Dot operator                |
| Pointer to struct  | `struct Student *p = &s1;`        | Points to structure         |
| Access via pointer | `p->name`                         | Arrow operator              |
| Typedef struct     | `typedef struct { ... } STUDENT;` | Creates alias for structure |

---

Excellent question ğŸ‘ â€” this is one of the **most important concepts** to understand about `scanf()` and **how C handles memory**.

Letâ€™s break it down clearly ğŸ‘‡

---

## ğŸ§© First, what `scanf()` does

`scanf()` needs the **address of a variable** so it knows **where in memory to store** the value that the user types.

So in general:

```c
scanf("%d", &x);
```

means â€œtake the number typed by the user and store it at the memory location of `x`.â€

Thatâ€™s why we use `&` (address-of operator) for **non-array** variables.

---

## ğŸ§  Now the difference:

| Type                    | Example          | What it actually stores                 | Do we need `&`? | Why                                            |
| ----------------------- | ---------------- | --------------------------------------- | --------------- | ---------------------------------------------- |
| **int**                 | `int age;`       | Just one integer value                  | âœ… **Yes**       | `age` is not an address â€” itâ€™s just a number   |
| **char**                | `char grade;`    | One character                           | âœ… **Yes**       | Same reason â€” not an address                   |
| **char array (string)** | `char name[50];` | Name of array is already an **address** | âŒ **No**        | Array name automatically gives its own address |

---

### ğŸ§  In more detail:

When you declare:

```c
char name[50];
```

`name` itself **represents the address** of the first character in memory (i.e., `&name[0]`).

So these are **equivalent**:

```c
scanf("%s", name);
```

and

```c
scanf("%s", &name[0]);
```

Thatâ€™s why you donâ€™t write `&name` â€” it would actually be a **pointer to the entire array**, not to its first character.

---

## ğŸ§© In your example:

```c
scanf("%s %s %d %d %c", s1.name, s1.lname, &s1.age, &s1.grade, &s1.letterGrade);
```

* `s1.name` â†’ array â†’ already acts as address âœ…
* `s1.lname` â†’ array â†’ already acts as address âœ…
* `s1.age` â†’ integer â†’ need `&` âŒ
* `s1.grade` â†’ integer â†’ need `&` âŒ
* `s1.letterGrade` â†’ character â†’ need `&` âŒ

---

## ğŸ’¡ Rule of Thumb

| Variable Type                    | Example        | In `scanf` use      |
| -------------------------------- | -------------- | ------------------- |
| `int`, `float`, `double`, `char` | `x`, `y`, `z`  | `&x`, `&y`, `&z`    |
| `char array`                     | `char str[20]` | just `str` (no `&`) |

---

## ğŸ§  Quick Visualization

Imagine memory like boxes:

| Variable  | Memory Address | Value |
| --------- | -------------- | ----- |
| `age`     | `0x1000`       | `18`  |
| `name[0]` | `0x2000`       | `'A'` |
| `name[1]` | `0x2001`       | `'l'` |

* For `age`, you must tell `scanf` **"store the input at address 0x1000"** â†’ `&age`
* For `name`, `scanf` already knows the arrayâ€™s address â†’ just `name`

---

âœ… **Final Working Input Line:**

```c
scanf("%s %s %d %d %c", s1.name, s1.lname, &s1.age, &s1.grade, &s1.letterGrade);
```

---


